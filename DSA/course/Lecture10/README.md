## 🍕 manacher 算法 - 回文子串

【经典解法】： 添加虚字符串，比如 1234 变成 #1#2#3#4#，然后对每一位都往两边扩，比较回文。

【经典解法时间复杂度】： O(N^2)

核心信息：
- 每个位置的回文半径（或回文直径）数组。
- 一个变量 R ：之前所扩的所有位置中，所到达的最右侧的回文右边界。 这个变量只会变大，初始值为 -1
- 一个变量 C ：当你取得最远右边界 R 时，对应的中心点在哪里。 所以 R 和 C 是一起更新的。

玩一下：
- 情况 1 ，到达了最远右边界之外，此时只能以该点往两边 “暴力扩”。
- 情况 2 ，到达的点 i 属于右边界内部。则 i 一定是在 C 与 R 之间（原因是最远右边界 R 一定是前面对 C 点暴力扩时找出来的），所以此时的点一定有一个对称点 j
    - 如果 j 的回文半径在 C 的半径之内， 则 i 点的回文半径等于 j 。这个很好理解。
    - 如果 j 的回文半径在 C 的半径之外， 则 i 点的回文半径等于 i 到 R 的距离。 下面有证明
    - 如果 j 的回文半径刚好与 C 的左边界半径压线， 则 i 直接从 R 外面继续 “暴力扩”。 这算是一个小加速，因为中间部分不需要判断了，一定回文。

证明 “如果 j 的回文半径在 C 的半径之外， 则 i 点的回文半径等于 i 到 R 的距离。”
```
  L                                 R
  |                                 |
X |....j....Y      C      Z....i....|P
  |                                 |
首先， X 一定等于 Y ，因为它们根据 j 对称
其次， Y 一定等于 Z ，因为他们根据 C 对称
假设 i 的回文半径大于 i 到 R 距离，说明 Z 等于 P ，此时有 X 也等于 P ，这意味着 C 的半径可以更长。
所以假设不成立
```

时间复杂度是 O(N) ，很好理解，因为每次循环，如果 i 在 R 内部，时间复杂度是 O(1) ，如果 i 不在 R 内部，那么也会让 R 变大。
也就是不管什么情况，每次都会离 “终点” 更近，而且不会回退。 有点类似于 KMP ，但是比 KMP 容易分析很多。

```java
char[] manacherString(String str) {
    char[] charArr = str.toCharArray();
    char[] res = new char[str.length() * 2 + 1];
    int index = 0;
    for (int i = 0; i != res.length; i++) {
        res[i] = (i & 1) == 0? '#' : charArr[index++];
    }
    return res;
}
int maxLcpsLength(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = manacherString(s);
    int[] pArr = new int[str.length];
    int C = -1;
    int R_next = -1; // 这个 R_next 是前面解释中 R 的下一个位置， 即 C 的半径范围是 [L...C...R_next-1] R 。 这里只是方便理解才写成 R_next，实际上写成 R 也是可以的。
    int max = Integer.MIN_VALUE;
    for (int i = 0; i != str.length; i++) {

        // 这句代码，囊括了很多种情况，得到的是可以直接从哪里开始“扩”
        int j = 2*C-i
        pArr[i] =
            R_next > i
                ? Math.min(pArr[j], R_next - i)  // i 在范围之内， R_next - i 就是 i 到 R 的半径距离。 pArr[j] 是 j 的半径距离。 这个包含了挺多
                                                    // 如果 j 半径在 C 之内， 则 pArr[j] 一定小于 R_next-i
                                                    // 如果 j 半径在 C 之外或刚好压到半径， 则 i 半径至少为 R_next-i
                : 1;    // i 在 R 范围之外，则只能保证 i 的回文半径一定大于等于 1

        while (i + pArr[i] < str.length && i - pArr[i] > -1) {
            // 直接从 R 之外开始继续判断是否回文 。
            if (str[i + pArr[i]] == str[i - pArr[i]]) {
                pArr[i]++;
            } else {
                // 如果 j 半径在 C 之内， 或者 j 半径在 C 之外，都会直接退出。 具体证明前面已经说明了。
                break;
            }
        }
        // 更新 C 和 R_next
        if (i + pArr[i] > R_next) {
            R_next = i + pArr[i];
            C = i;
        }
        max = Math.max(max, pArr(i));
    }
    // 最大的回文半径 - 1，就是原字符串的最大回文直径
    return max - 1;
}
```

## 🍕 窗口

【窗口】： 就是两个边界 L 和 R ，并且 L 永远不会超过 R ，它们两个也永远只会往一个方向移动。

【目标】： 每次都能够很快的获取窗口内的最大值，方法是借助维护一个有序的双端队列 —— 一段是最大值，另一端是最小值。

【双端队列】： 两段都可以出。 里面存储的是窗口所在数组的值的下标。

双端队列维护流程：
- 如果 R 移动， 判断 R 指向的值是否能插入到双端列队的最小值后面，如果无法插入，则弹出双端队列的最小值。 总之，确保 R 指向的值进入后能够在最大值后面，或者它就是最大值。 注意，如果队列内的值和 R 指向的值一样，那也要将其弹出。也就是保证 双端队列的 "单调性"
- 如果 L 移动，如果 L 所在位置下标是双端队列中最大值下标，则弹出双端队列的最大值，不是，则不管。

双端队列维持的信息是： 如果当前 R 不再动， L 一直动，谁会是最大值。

为什么 R 移动时可以弹出双端队列中的值： 因为新的值肯定比旧的值晚过期，而且新的值还比旧的值大，所以弹出的值是不可能再成为最大值的了，所以可以弹出。 这也是为什么值相同时，也要将其弹出。 因为新的值更晚过期。

更新代价：数组中每一个元素最多进队列一次，最多出队列一次。所以总的代价是 O(N) ，平均代价是 O(1)。

上面讲的是最大值的情况，最小值的情况是同理的。

## 🍕 单调栈

解决的问题： 求数组中每一个数字的两旁的距离最近的最大值。（最小值同理）

【单调栈】： 里面的元素一定是有序的，如果求取的是最大值，则栈底到栈顶方向是递减。

单调栈流程： 先假设数组中没有重复值
- 遍历每一个数字，判断该数字能不能进入栈中。 每当一个数字出栈时，就能够结算 —— 获取这个数字两边最近的最大值
- 如果要放入的数字小于栈顶元素 —— 能维持单调性，则将其压入
- 如果要放入的数字大于栈顶元素，则需要弹出某些元素
    - 弹出一个元素，它的左边最近最大值就是它弹出后的栈顶元素，它的右边最近最大值就是导致它弹出的数 —— 当前要放入的数字。
    - 也就是说，要放入的数字，是每一个弹出的元素的右边最大值，而弹出的元素的左边最大值，是它们弹出后的栈顶元素。
- 当遍历结束后，开始结束单调栈中剩余的元素
    - 遍历结束后才弹出的元素，说明他们的右边没有比它大的值了。
    - 而他们左边比它大的值，同样是弹出后的栈顶元素
    - 所以，最后弹出的元素，两边都没有最大值，因为它是整个数组的最大值。

没有重复值时，栈中每一个元素都只是一个数组中一个元素的下标。
- 当有重复值时，就是将栈中元素变成一个 “链表”，其他流程一样。
- 当要放入的元素和栈顶元素一样大时，直接放到该元素的链表后面。
- 当要弹出元素时，它的左边最大值，是栈顶元素的链表的最后一个元素。

【证明】:
- 假设现在要放入的元素是 c ，栈顶元素是 a ，元素 a 的的下一个值是 b
```
     <-- c
| a |  小
| b |  ↑
|...|  ↑
|___|  大
```
- 首先证明为什么 c 就是 a 的右边最大值
    - 首先， a...c 中间不可能有数字小于 a ，因为如果小于 a ，这个数字就入栈
    - 其次， a...c 中间不可能有数字大于 a ，如果这个数字大于 a ，那么 a 就会因为这个数字出栈了，而轮不到 c
- 再证明为什么 b 就是 a 的左侧最大值
    - 首先， b...a 中间数字有没有可能小于 a ，有可能！ 但这个数字一定会因为别人出栈了，不然就是当 a 进栈时这个数字就会出栈。
    - 其次， b...a 中间有没有可能大于 b ，不可能。因为大于 b 会将 b 弹出。
    - 最后， b...a 中间数字有没有可能大于 a 小于 10 ，不可能！
        - 假设 b 是 10 , a 是 7 ，中间数字是 8 ，如果没有数字将 8 弹出，那么 a 下面一定是 8 而不是 10。
        - 如果有数字将 8 弹出，该数字一定大于 8 ，假设是 9 ，那么，同理这个数字也一定会导致 a 和 b 之间有一个数字 9。
        - 如果又有数字比 9 大，那么这个数字会比 10 还大，那么 10 就不会留在栈中了。
        - 所以， b...a 中间不可能有数字大于 a 小于 10


【题目】定义:数组中累积和与最小值的乘积，假设叫做指标 A 。给定一个数组，请返回子数组中，指标 A 最大的值。

解释： 每一个数字都可以是某个多个数组的最小值，在这么多个数组，选取哪一个呢？ 选取累加和最大的那个数组。

解题敏感性： 这就是单调栈问题， 对每一个数字，都查找两边最近的最小值，这两个最小值围起来的区域就是以该数字为最小值所能够到达的最大区域，那么它的累加和肯定就是最大！

